/**********************************************************************
 *
 * PostGIS - Spatial Types for PostgreSQL
 * http://postgis.net
 *
 * PostGIS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * PostGIS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PostGIS.  If not, see <http://www.gnu.org/licenses/>.
 *
 **********************************************************************
 *
 * Copyright 2019 Mike Taves
 *
 **********************************************************************/


#include <stdlib.h>
#include <stdint.h>
/* #include <stdio.h> */

#include "lwrandom.h"
#include <stdlib.h>
#include <time.h>


static unsigned char _lwrandom_seed_set = 0;
static int32_t _lwrandom_seed[3] = {0x330e, 0xabcd, 0x1234};

/*
 * Set seed for a random number generator.
 * A zero value uses clock as seed the first time only.
 */
void
lwrandom_set_seed(uint32_t seed)
{
	if (seed == 0)
	{
		if (_lwrandom_seed_set == 0)
			seed = ((unsigned int)time(NULL) * 1996) << 8;
		else
			return;
	}

	_lwrandom_seed[1] = (seed % 2147483562) + 1; /* value between 1 and 2147483562 */
	_lwrandom_seed[2] = (((seed + 6) >> 12) % 2147483398) + 1; /* value between 1 and 2147483398 */
	_lwrandom_seed_set = 1;
}

/*
 * Generate a random floating-point value.
 * Values are uniformly distributed between 0 and 1.
 *
 * Author:
 *   Original PASCAL version by Pierre L'Ecuyer.
 *   C version by John Burkardt, modified by Mike Taves.
 *
 * Reference:
 *   Pierre L'Ecuyer,
 *   Efficient and Portable Combined Random Number Generators,
 *   Communications of the ACM,
 *   Volume 31, Number 6, June 1988, pages 742-751.
 */
double
lwrandom_uniform(void)
{
	double value;
	int32_t k;
	int32_t z;
	int32_t *s1 = &_lwrandom_seed[1];
	int32_t *s2 = &_lwrandom_seed[2];

	k = *s1 / 53668;
	*s1 = 40014 * ( *s1 - k * 53668 ) - k * 12211;
	if ( *s1 < 0 )
		*s1 += 2147483563;

	k = *s2 / 52774;
	*s2 = 40692 * ( *s2 - k * 52774 ) - k * 3791;
	if ( *s2 < 0 )
		*s2 += 2147483399;

	z = *s1 - *s2;
	if ( z < 1 )
		z += 2147483562;

	value = ( double ) ( z ) / 2147483563.0;

	return value;
}

/* See asa183_prb.c and asa183_prb_output.txt by John Burkardt

void test10 ( )
{
	int i;
	double r;
	int32_t *s1 = &_lwrandom_seed[1];
	int32_t *s2 = &_lwrandom_seed[2];

	printf ( "\n" );
	printf ( "TEST10\n" );
	printf ( "  R8_UNI computes pseudorandom values.\n" );
	printf ( "  Two seeds, S1 and S2, are used.\n" );

	*s1 = 12345;
	*s2 = 34567;

	printf ( "\n" );
	printf ( "      R                     S1            S2\n" );
	printf ( "\n" );
	printf ( "                  %12d  %12d\n", *s1, *s2 );

	for ( i = 0; i < 10; i++ )
	{
		r = lwrandom_uniform();
		printf ( "  %14f  %12d  %12d\n", r, *s1, *s2 );
	}
	return;
}

void test11 ( )
{
	int i;
	int n = 100000;
	int32_t *s1 = &_lwrandom_seed[1];
	int32_t *s2 = &_lwrandom_seed[2];
	double *u;
	double u_avg;
	double u_var;

	u = ( double * ) malloc ( n * sizeof ( double ) );

	printf ( "\n" );
	printf ( "TEST11\n" );
	printf ( "  Examine the average and variance of a\n" );
	printf ( "  sequence generated by R8_UNI.\n" );

	*s1 = 12345;
	*s2 = 34567;

	printf ( "\n" );
	printf ( "  Now compute %d elements.\n", n );

	u_avg = 0.0;
	for ( i = 0; i < n; i++ )
	{
		u[i] = lwrandom_uniform();
		u_avg += u[i];
	}

	u_avg = u_avg / ( float ) ( n );

	u_var = 0.0;
	for ( i = 0; i < n; i++ )
	{
		u_var += ( u[i] - u_avg ) * ( u[i] - u_avg );
	}

	u_var = u_var / ( float ) ( n - 1 );

	printf ( "\n" );
	printf ( "  Average value = %f\n", u_avg );
	printf ( "  Expecting       %f\n", 0.5 );;

	printf ( "\n" );
	printf ( "  Variance =      %f\n", u_var );
	printf ( "  Expecting       %f\n", 1.0 / 12.0 );

	free ( u );

	return;
}

void test12 ( )
{
	int i;
	double r;
	int32_t *s1 = &_lwrandom_seed[1];
	int32_t *s2 = &_lwrandom_seed[2];
	int32_t s1_save;
	int32_t s2_save;

	printf ( "\n" );
	printf ( "TEST12\n" );
	printf ( "  Show how the seeds used by R8_UNI,\n" );
	printf ( "  which change on each step, can be reset to\n" );
	printf ( "  restore any part of the sequence.\n" );

	s1_save = 12345;
	s2_save = 34567;

	*s1 = s1_save;
	*s2 = s2_save;

	printf ( "\n" );
	printf ( "  Begin sequence with following seeds\n" );
	printf ( "\n" );
	printf ( "  S1 = %d\n", *s1 );
	printf ( "  S2 = %d\n", *s2 );
	printf ( "\n" );
	printf ( "         I      R                     S1            S2\n" );
	printf ( "\n" );

	for ( i = 1; i <= 10; i++ )
	{
		r = lwrandom_uniform();
		printf ( "  %8d  %14f  %12d  %12d\n", i, r, *s1, *s2 );

		if ( i == 5 )
		{
			s1_save = *s1;
			s2_save = *s2;
		}
	}
	*s1 = s1_save;
	*s2 = s2_save;

	printf ( "\n" );
	printf ( "  Restart the sequence, using the seeds\n" );
	printf ( "  produced after step 5:\n" );
	printf ( "\n" );
	printf ( "  S1 = %d\n", *s1 );
	printf ( "  S2 = %d\n", *s2 );
	printf ( "\n" );
	printf ( "         I      R                     S1            S2\n" );
	printf ( "\n" );

	for ( i = 1; i <= 10; i++ )
	{
		r = lwrandom_uniform();
		printf ( "  %8d  %14f  %12d  %12d\n", i, r, *s1, *s2 );
	}
	return;
}

int main()
{
	test10();
	test11();
	test12();
	return 0;
}

int main()
{
	double r;
	int i;
	lwrandom_set_seed(0);
	r = lwrandom_uniform();
	printf("%14f\n", r);
	lwrandom_set_seed(0);
	r = lwrandom_uniform();
	printf("%14f\n", r);
	// return 0;
	lwrandom_set_seed(1234);
	for (i=1; i<=10; i++)
	{
		r = lwrandom_uniform();
		printf("%8d %14f\n", i, r);
	}
	lwrandom_set_seed(1234);
	for (i=1; i<=10; i++)
	{
		r = lwrandom_uniform();
		printf("%8d %14f\n", i, r);
	}
	return 0;
}
*/
